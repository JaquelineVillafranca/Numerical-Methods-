import sys
sys.path.append(r"C:\Users\Roberto\AppData\Local\Programs\Python\Python38-32\Lib\site-packages")
from matplotlib import pyplot as plt
import sympy
from sympy import Symbol, Derivative


# Estimated point root (ONE ROOT ONLY) #

#X1 lo esocojo lejos de cero
xi= 4
es= 0.0001

mathematicaRoot= 1

#Raphson-Newton method-------------------------------------------------------------------------------------------------#
def f(x):
    y= x**8 - 1
    return y

# Find derivate of the function f(x) at a point xi #
def df(xi):
    x = Symbol('x')
    func = f(x)
    deriv = Derivative(func, x)
    return float(deriv.doit().subs({x: xi}))

# Find double derivate of the function f(x) at a point xi #
def ddf(xi):
    x = Symbol('x')
    func = f(x)
    deriv = Derivative(func, x)
    func2 = deriv
    deriv2 = Derivative(func2, x)
    return float(deriv2.doit().subs({x: xi}))

def u(x):
    return float( f(x) / df(x) )

def du(x):
    return float( (pow(df(x), 2) - f(x) * ddf(x)) / pow(df(x), 2) )

i= 0
while i <= 500:
    # General Formula #
    xi1 = float(xi - u(xi) / du(xi))

    # Zero check for the function #
    if abs(f( xi + 1 )) < 10**-7:
        print("\nNo. of iterations: " + str(i + 1))
        print(xi1)
        print("\nAccuracy: " + str(abs(1 - ((abs(mathematicaRoot - xi1) / xi1) * 100))) + " %")
        break

    # Convergence criterion #
    ea = float( abs( (xi1 - xi) / xi1) )

    if ea < es:
        print("\nNo. of iterations: " + str(i + 1))
        print(xi1)
        print("\nAccuracy: " + str(abs(1 - ((abs(mathematicaRoot - xi1) / xi1) * 100))) + " %")
        break

    # Reassignment of the x values #
    xi = xi1

    # Last iteration -> did not converge #
    if i == 500:
        print("\nDid not converge in " + str(i) + " iterations")

    i+= 1
